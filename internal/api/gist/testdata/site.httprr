httprr trace v1
313 14397
GET https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081 HTTP/1.1
Host: api.github.com
User-Agent: gist.test/ (+https://astrophena.name/bleep-bloop)
Transfer-Encoding: chunked
Accept: application/vnd.github+json
Content-Type: application/json
X-Github-Api-Version: 2022-11-28

1
n
3
ull
0

HTTP/2.0 200 OK
Accept-Ranges: bytes
Access-Control-Allow-Origin: *
Access-Control-Expose-Headers: ETag, Link, Location, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Used, X-RateLimit-Resource, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval, X-GitHub-Media-Type, X-GitHub-SSO, X-GitHub-Request-Id, Deprecation, Sunset
Cache-Control: public, max-age=60, s-maxage=60
Content-Security-Policy: default-src 'none'
Content-Type: application/json; charset=utf-8
Date: Wed, 26 Jun 2024 17:51:38 GMT
Etag: W/"48196eb33b5fb44358bb4da0f57cca03b85b92479902c0155db5c5de07d17739"
Last-Modified: Sun, 23 Jun 2024 17:34:48 GMT
Referrer-Policy: origin-when-cross-origin, strict-origin-when-cross-origin
Server: GitHub.com
Strict-Transport-Security: max-age=31536000; includeSubdomains; preload
Vary: Accept, Accept-Encoding, Accept, X-Requested-With
X-Content-Type-Options: nosniff
X-Frame-Options: deny
X-Github-Api-Version-Selected: 2022-11-28
X-Github-Media-Type: github.v3; format=json
X-Github-Request-Id: 0772:C18A3:197AA0AB:19B92D31:667C552A
X-Ratelimit-Limit: 60
X-Ratelimit-Remaining: 53
X-Ratelimit-Reset: 1719424772
X-Ratelimit-Resource: core
X-Ratelimit-Used: 7
X-Xss-Protection: 0

{"url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081","forks_url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081/forks","commits_url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081/commits","id":"98c0eeb72ee0bdba33c24d1e19780081","node_id":"G_kwDOA30FbtoAIDk4YzBlZWI3MmVlMGJkYmEzM2MyNGQxZTE5NzgwMDgx","git_pull_url":"https://gist.github.com/98c0eeb72ee0bdba33c24d1e19780081.git","git_push_url":"https://gist.github.com/98c0eeb72ee0bdba33c24d1e19780081.git","html_url":"https://gist.github.com/astrophena/98c0eeb72ee0bdba33c24d1e19780081","files":{"site.go":{"filename":"site.go","type":"text/plain","language":"Go","raw_url":"https://gist.githubusercontent.com/astrophena/98c0eeb72ee0bdba33c24d1e19780081/raw/91ee15ef163d8621e51731ed1365280115d5bc07/site.go","size":7820,"truncated":false,"content":"package main\n\nimport (\n\t\"archive/zip\"\n\t\"bytes\"\n\t\"context\"\n\t\"errors\"\n\t\"fmt\"\n\t\"io\"\n\t\"io/fs\"\n\t\"net/http\"\n\t\"net/url\"\n\t\"path\"\n\t\"path/filepath\"\n\t\"strings\"\n\t\"sync\"\n\t\"time\"\n\n\t\"go.uber.org/zap\"\n\t\"golang.org/x/time/rate\"\n)\n\ntype site struct {\n\tconf  *config\n\tlog   *zap.Logger\n\tstore store // if not nil, last version of the site is persisted here\n\n\tinit    sync.Once // loads the last version from store, if it's available\n\tinitErr error     // error during initOnce\n\n\tupdateLimitersMu sync.Mutex\n\tlastCleaned      time.Time\n\tlastCleanedCount int\n\tupdateLimiters   map[string]*updateLimiter\n\n\tmu      sync.RWMutex // protects fs and handler\n\tfs      fs.FS        // current version of the site\n\thandler http.Handler // handles site requests, see s.update\n}\n\nconst (\n\tupdateAttempts      = 3\n\tupdateAttemptsDelay = 10 * time.Minute\n)\n\ntype updateLimiter struct {\n\tlimiter  *rate.Limiter\n\tlastSeen time.Time\n}\n\nfunc (s *site) getUpdateLimiter(ip string) *rate.Limiter {\n\ts.updateLimitersMu.Lock()\n\tdefer s.updateLimitersMu.Unlock()\n\n\tlim, ok := s.updateLimiters[ip]\n\tif !ok {\n\t\tlim = &updateLimiter{\n\t\t\tlimiter: rate.NewLimiter(rate.Every(updateAttemptsDelay), updateAttempts),\n\t\t}\n\t\ts.updateLimiters[ip] = lim\n\t}\n\tlim.lastSeen = time.Now()\n\treturn lim.limiter\n}\n\n// cleanupUpdateLimiters removes update rate limiters that haven't been used for\n// than an hour. It runs in a separate goroutine.\nfunc (s *site) cleanupUpdateLimiters(ctx context.Context) {\n\ts.init.Do(s.initOnce)\n\tticker := time.NewTicker(1 * time.Hour)\n\ts.log.Debug(\"started cleaning up old update rate limiters\")\nloop:\n\tfor {\n\t\tselect {\n\t\tcase <-ticker.C:\n\t\t\ts.updateLimitersMu.Lock()\n\t\t\tvar cleaned int\n\t\t\tfor ip, v := range s.updateLimiters {\n\t\t\t\tif time.Since(v.lastSeen) > 6*updateAttemptsDelay {\n\t\t\t\t\tdelete(s.updateLimiters, ip)\n\t\t\t\t\tcleaned++\n\t\t\t\t}\n\t\t\t}\n\t\t\ts.lastCleaned = time.Now()\n\t\t\ts.lastCleanedCount = cleaned\n\t\t\ts.updateLimitersMu.Unlock()\n\t\t\ts.log.Debug(\"cleaned old update rate limiters\", zap.Int(\"count\", cleaned))\n\t\tcase <-ctx.Done():\n\t\t\tticker.Stop()\n\t\t\tbreak loop\n\t\t}\n\t}\n\ts.log.Debug(\"stopped cleaning up old update rate limiters\")\n}\n\nfunc (s *site) handleUpdateLimiters(w http.ResponseWriter, r *http.Request) {\n\ts.updateLimitersMu.Lock()\n\tdefer s.updateLimitersMu.Unlock()\n\n\tfmt.Fprintf(w, `<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n<meta charset=\"utf-8\">\n<meta name=\"viewport\" content=\"width=device-width,initial-scale=1\">\n<title>/update rate limiter</title>\n</head>\n<body>\n<h1>/update rate limiter</h1>\n<p>Cleanup last ran %[1]v, removed %[2]v.</p>\n<table>\n<tr>\n<th>IP</th>\n<th>Last seen</th>\n</tr>`, s.lastCleaned, s.lastCleanedCount)\n\n\tfor ip, ul := range s.updateLimiters {\n\t\tfmt.Fprintf(w, `<tr>\n<td>%[1]s</td>\n<td>%[2]v</td>\n</tr>`, ip, time.Since(ul.lastSeen))\n\t}\n\n\tw.Write([]byte(`</table>\n</html>`))\n}\n\nfunc (s *site) initOnce() {\n\tif err := func() error {\n\t\ts.updateLimiters = make(map[string]*updateLimiter)\n\n\t\tif s.store == nil {\n\t\t\treturn nil\n\t\t}\n\n\t\tb, err := s.store.Get(\"site\")\n\t\tif err != nil {\n\t\t\tif errors.Is(err, errStoreNoKey) {\n\t\t\t\treturn nil\n\t\t\t}\n\t\t\treturn err\n\t\t}\n\n\t\treturn s.update(b)\n\t}(); err != nil {\n\t\ts.initErr = err\n\t}\n}\n\nfunc (s *site) handleUpdate(w http.ResponseWriter, r *http.Request) {\n\tlim := s.getUpdateLimiter(r.RemoteAddr)\n\tif !lim.Allow() {\n\t\thttp.Error(w, \"too many requests\", http.StatusTooManyRequests)\n\t\treturn\n\t}\n\n\ttoken := strings.TrimPrefix(r.Header.Get(\"Authorization\"), \"Bearer \")\n\tif token != s.conf.adminToken {\n\t\thttp.Error(w, \"invalid auth token\", http.StatusUnauthorized)\n\t\treturn\n\t}\n\n\tif r.Method != http.MethodPut {\n\t\thttp.Error(w, fmt.Sprintf(\"use method PUT, not %s\", r.Method), http.StatusMethodNotAllowed)\n\t\treturn\n\t}\n\n\tfile, header, err := r.FormFile(\"content\")\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\treturn\n\t}\n\tdefer file.Close()\n\n\text := filepath.Ext(header.Filename)\n\tif ext != \".zip\" {\n\t\thttp.Error(w, fmt.Sprintf(\"got file with extension %s, want .zip\", ext), http.StatusBadRequest)\n\t\treturn\n\t}\n\n\tb, err := io.ReadAll(file)\n\tif err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif err := s.update(b); err != nil {\n\t\tif errors.Is(err, zip.ErrFormat) {\n\t\t\thttp.Error(w, err.Error(), http.StatusBadRequest)\n\t\t\treturn\n\t\t}\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tif s.store != nil {\n\t\tif err := s.store.Set(\"site\", b); err != nil {\n\t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\t\treturn\n\t\t}\n\t}\n\n\tw.WriteHeader(http.StatusNoContent)\n}\n\n// update replaces the current version of the site by a new one. b should be a\n// valid ZIP archive.\nfunc (s *site) update(b []byte) error {\n\ts.mu.Lock()\n\tdefer s.mu.Unlock()\n\n\tfs, err := zip.NewReader(bytes.NewReader(b), int64(len(b)))\n\tif err != nil {\n\t\treturn err\n\t}\n\ts.fs = &neuteredFS{&seekableFS{fs}}\n\ts.handler = http.FileServer(http.FS(s.fs))\n\n\treturn nil\n}\n\n// neuteredFS is a fs.FS that hides http.FileServer's directory listings.\ntype neuteredFS struct {\n\tfs fs.FS\n}\n\n// Open implements the fs.FS interface.\nfunc (nfs neuteredFS) Open(name string) (fs.File, error) {\n\tf, err := nfs.fs.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\ts, err := f.Stat()\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\n\tif s.IsDir() {\n\t\tindex := filepath.Join(name, \"index.html\")\n\t\tif _, err := nfs.fs.Open(index); err != nil {\n\t\t\tcloseErr := f.Close()\n\t\t\tif closeErr != nil {\n\t\t\t\treturn nil, closeErr\n\t\t\t}\n\n\t\t\treturn nil, err\n\t\t}\n\t}\n\n\treturn f, nil\n}\n\nfunc (s *site) ServeHTTP(w http.ResponseWriter, r *http.Request) {\n\ts.init.Do(s.initOnce)\n\tif s.initErr != nil {\n\t\thttp.Error(w, s.initErr.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\tswitch r.URL.Path {\n\tcase \"/update\":\n\t\ts.handleUpdate(w, r)\n\t\treturn\n\tcase \"/setup\":\n\t\thttp.Redirect(w, r, \"https://raw.githubusercontent.com/astrophena/dotfiles/master/script/setup\", http.StatusFound)\n\t\treturn\n\t// Old URLs:\n\tcase \"/hello-world\", \"/hello-world/\":\n\t\tserveRedirect(func(u *url.URL) {\n\t\t\tu.Host = s.conf.domain\n\t\t\tu.Path = \"/hello/\"\n\t\t})(w, r)\n\t\treturn\n\t}\n\n\ts.mu.RLock()\n\tdefer s.mu.RUnlock()\n\n\tif s.handler == nil {\n\t\thttp.Error(w, \"s.handler is nil\", http.StatusInternalServerError)\n\t\treturn\n\t}\n\n\t// First check if a file or directory that we want to serve does exist, and if\n\t// not, serve the 404 page.\n\tpath := strings.TrimPrefix(path.Clean(r.URL.Path), \"/\")\n\tif _, err := fs.Stat(s.fs, path); errors.Is(err, fs.ErrNotExist) {\n\t\ts.serveNotFound(w, r)\n\t\treturn\n\t}\n\ts.handler.ServeHTTP(w, r)\n}\n\n// serveNotFound serves the 404 page.\nfunc (s *site) serveNotFound(w http.ResponseWriter, r *http.Request) {\n\tf, err := s.fs.Open(\"404.html\")\n\tif errors.Is(err, fs.ErrNotExist) {\n\t\thttp.NotFound(w, r)\n\t\treturn\n\t} else if err != nil {\n\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n\t\treturn\n\t}\n\tdefer f.Close()\n\tw.WriteHeader(http.StatusNotFound)\n\tio.Copy(w, f)\n}\n\n// seekableFS is an fs.FS wrapper that makes every file seekable by reading it\n// entirely into memory when it is opened and then serving read operations\n// (including seek) from the memory copy.\ntype seekableFS struct {\n\tfs fs.FS\n}\n\nfunc (s *seekableFS) Open(name string) (fs.File, error) {\n\tf, err := s.fs.Open(name)\n\tif err != nil {\n\t\treturn nil, err\n\t}\n\tinfo, err := f.Stat()\n\tif err != nil {\n\t\tf.Close()\n\t\treturn nil, err\n\t}\n\tif info.IsDir() {\n\t\treturn f, nil\n\t}\n\tdata, err := io.ReadAll(f)\n\tif err != nil {\n\t\tf.Close()\n\t\treturn nil, err\n\t}\n\tvar sf seekableFile\n\tsf.File = f\n\tsf.Reset(data)\n\treturn &sf, nil\n}\n\n// seekableFile is a fs.File augmented by an in-memory copy of the file data to\n// allow use of Seek.\ntype seekableFile struct {\n\tbytes.Reader\n\tfs.File\n}\n\n// Read calls f.Reader.Read. Both f.Reader and f.File have Read methods — a\n// conflict — so f inherits neither. This method calls the one we want.\nfunc (f *seekableFile) Read(b []byte) (int, error) {\n\treturn f.Reader.Read(b)\n}\n"}},"public":true,"created_at":"2022-10-08T17:39:40Z","updated_at":"2023-11-03T16:54:08Z","description":"HTTP server that serves static site in a ZIP archive","comments":0,"user":null,"comments_url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081/comments","owner":{"login":"astrophena","id":58525038,"node_id":"MDQ6VXNlcjU4NTI1MDM4","avatar_url":"https://avatars.githubusercontent.com/u/58525038?v=4","gravatar_id":"","url":"https://api.github.com/users/astrophena","html_url":"https://github.com/astrophena","followers_url":"https://api.github.com/users/astrophena/followers","following_url":"https://api.github.com/users/astrophena/following{/other_user}","gists_url":"https://api.github.com/users/astrophena/gists{/gist_id}","starred_url":"https://api.github.com/users/astrophena/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astrophena/subscriptions","organizations_url":"https://api.github.com/users/astrophena/orgs","repos_url":"https://api.github.com/users/astrophena/repos","events_url":"https://api.github.com/users/astrophena/events{/privacy}","received_events_url":"https://api.github.com/users/astrophena/received_events","type":"User","site_admin":false},"forks":[],"history":[{"user":{"login":"astrophena","id":58525038,"node_id":"MDQ6VXNlcjU4NTI1MDM4","avatar_url":"https://avatars.githubusercontent.com/u/58525038?v=4","gravatar_id":"","url":"https://api.github.com/users/astrophena","html_url":"https://github.com/astrophena","followers_url":"https://api.github.com/users/astrophena/followers","following_url":"https://api.github.com/users/astrophena/following{/other_user}","gists_url":"https://api.github.com/users/astrophena/gists{/gist_id}","starred_url":"https://api.github.com/users/astrophena/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astrophena/subscriptions","organizations_url":"https://api.github.com/users/astrophena/orgs","repos_url":"https://api.github.com/users/astrophena/repos","events_url":"https://api.github.com/users/astrophena/events{/privacy}","received_events_url":"https://api.github.com/users/astrophena/received_events","type":"User","site_admin":false},"version":"b82c6830bed3e9a843283561ba203a5bde254f3f","committed_at":"2023-11-03T16:54:08Z","change_status":{"total":0,"additions":0,"deletions":0},"url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081/b82c6830bed3e9a843283561ba203a5bde254f3f"},{"user":{"login":"astrophena","id":58525038,"node_id":"MDQ6VXNlcjU4NTI1MDM4","avatar_url":"https://avatars.githubusercontent.com/u/58525038?v=4","gravatar_id":"","url":"https://api.github.com/users/astrophena","html_url":"https://github.com/astrophena","followers_url":"https://api.github.com/users/astrophena/followers","following_url":"https://api.github.com/users/astrophena/following{/other_user}","gists_url":"https://api.github.com/users/astrophena/gists{/gist_id}","starred_url":"https://api.github.com/users/astrophena/starred{/owner}{/repo}","subscriptions_url":"https://api.github.com/users/astrophena/subscriptions","organizations_url":"https://api.github.com/users/astrophena/orgs","repos_url":"https://api.github.com/users/astrophena/repos","events_url":"https://api.github.com/users/astrophena/events{/privacy}","received_events_url":"https://api.github.com/users/astrophena/received_events","type":"User","site_admin":false},"version":"7460a506da12fb48c17a7b2a6ba959f760109b66","committed_at":"2022-10-08T17:39:40Z","change_status":{"total":349,"additions":349,"deletions":0},"url":"https://api.github.com/gists/98c0eeb72ee0bdba33c24d1e19780081/7460a506da12fb48c17a7b2a6ba959f760109b66"}],"truncated":false}