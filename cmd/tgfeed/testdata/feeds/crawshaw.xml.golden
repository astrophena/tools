[
 {
  "title": "jsonfile: a quick hack for tinkering",
  "content": "\n\t\u003ch1\u003ejsonfile: a quick hack for tinkering\u003c/h1\u003e\n\n\u003cp\u003e\u003cem\u003e2024-02-06\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eThe year is 2024.\nI am on vacation and dream up a couple of toy programs I would like to build.\nIt has been a few years since I built a standalone toy, I have \u003ca href=\"https://crawshaw.io/blog/remembering-the-lan\"\u003ebeen busy\u003c/a\u003e.\nSo instead of actually building any of the toys I think of, I spend my time researching if anything has changed since the last time I did it.\nShould pick up new tools or techniques?\u003c/p\u003e\n\n\u003cp\u003eIt turns out lots of things have changed!\nThereâ€™s some great stuff out there, including decent quorum-write regional cloud databases now.\nOh and the ability to have a fascinating hour-long novel conversation with transistors.\nBut things are still awkward for small fast tinkering.\u003c/p\u003e\n\n\u003cp\u003eGoing back in time, I struggled constantly rewriting the database for the prototype for Tailscale, so I ended up writing my in-memory objects out as \u003ca href=\"https://tailscale.com/blog/an-unlikely-database-migration\"\u003ea JSON file\u003c/a\u003e.\nIt went far further than I planned.\nSomewhere in the intervening years I convinced myself it must have been a bad idea even for toys, given all the pain migrating away from it caused.\nBut now that I find myself in an empty text editor wanting to write a little web server, I am not so sure.\nThe migration was painful, and a lot of that pain was born by others (which is unfortunate, I find handing a mess to someone else deeply unpleasant).\nMuch of that pain came from the brittle design of the caching layers on top (also my doing), which came from not moving to an SQL system soon enough.\u003c/p\u003e\n\n\u003cp\u003eI suspect, considering the process retrospect, a great deal of that pain can be avoided by committing to migrating directly to an SQL system the moment you need an index.\nYou can pay down a lot of exploratory design work in a prototype before you need an index, which n is small, full scans are fine.\nBut you donâ€™t make it very far into production before one of your values of n crosses something around a thousand and you long for an index.\u003c/p\u003e\n\n\u003cp\u003eWith a clear exit strategy for avoiding big messes, that means the JSON file as database is still a valid technique for prototyping.\nAnd having spent a couple of days remembering what a misery it is to write a unit test for software that uses postgresql (mocks? docker?? for a database program I first ran on a computer with less power than my 2024 wrist watch?) and struggling figuring out how to make my cgo sqlite cross-compile to Windows, Iâ€™m firmly back to thinking a JSON file can be a perfectly adequate database for a 200-line toy.\u003c/p\u003e\n\n\u003ch1\u003eConsider your requirements!\u003c/h1\u003e\n\n\u003cp\u003eBefore you jump into this and discover it wonâ€™t work, or just as bad, dismiss the small and unscaling as always a bad idea, consider the requirements of your software.\nUsing a JSON file as a database means your software:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eDoesnâ€™t have a lot of data. Keep it to a few megabytes.\u003c/li\u003e\n\u003cli\u003eThe data structure is boring enough not to require indexes.\u003c/li\u003e\n\u003cli\u003eYou donâ€™t need something interesting like full-text search.\u003c/li\u003e\n\u003cli\u003eYou do plenty of reads, but writes are infrequent. Ideally no more than one every few seconds.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eProgramming is the art of tradeoffs.\nYou have to decide what matters and what does not.\nSome of those decisions need to be made early, usually with imperfect information.\nYou may very well need a powerful SQL DBMS from the moment you start programming, depending on the kind of program youâ€™re writing!\u003c/p\u003e\n\n\u003ch1\u003eA reference implementation\u003c/h1\u003e\n\n\u003cp\u003eAn implementation of jsonfile (which Brad called JSONMutexDB, which is cooler because it has an x in it, but requires more typing) can fit in about 70 lines of Go.\nBut there are a couple of lessons we ran into in the early days of Tailscale that can be paid down relatively easily, growing the implementation to 85 lines.\n(More with comments!)\nI think itâ€™s worth describing the interesting things we ran into, both in code and here.\u003c/p\u003e\n\n\u003cp\u003eYou can find the implementation of jsonfile here: \u003ca href=\"https://github.com/crawshaw/jsonfile/blob/main/jsonfile.go\"\u003ehttps://github.com/crawshaw/jsonfile/blob/main/jsonfile.go\u003c/a\u003e. The interface is:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003etype JSONFile[Data any] struct { â€¦ }\n\nfunc New[Data any](path string) (*JSONFile[Data], error)\nfunc Load[Data any](path string) (*JSONFile[Data], error)\nfunc (p *JSONFile[Data]) Read(fn func(data *Data))\nfunc (p *JSONFile[Data]) Write(fn func(*Data) error) error\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003cp\u003eThere is some experience behind this design.\nIn no particular order:\u003c/p\u003e\n\n\u003ch2\u003eTransactions\u003c/h2\u003e\n\n\u003cp\u003eOne of the early pain points in the transition was figuring out the equivalent of when to \u003ccode\u003eBEGIN\u003c/code\u003e, \u003ccode\u003eCOMMIT\u003c/code\u003e, and \u003ccode\u003eROLLBACK\u003c/code\u003e.\nThe first version exposed the mutex directly (which was later converted into a RWMutex).\u003c/p\u003e\n\n\u003cp\u003eThere is no advantage to paying this transition cost later.\nIt is easy to box up read/write transactions with a callback.\nThis API does that, and provides a great point to include other safety mechanisms.\u003c/p\u003e\n\n\u003ch2\u003eDatabase corruption through partial writes\u003c/h2\u003e\n\n\u003cp\u003eThere are two forms of this. The first is if the write fn fails half-way through, having edited the db object in some way. To avoid this, the implementation first creates an entirely new copy of the DB before applying the edit, so the entire change set can be thrown away on error. Yes, this is inefficient. No, it doesnâ€™t matter. Inefficiency in this design is dominated by the I/O required to write the entire database on every edit. If you are concerned about the duplicate-on-write cost, you are not modeling I/O cost appropriately (which is important, because if I/O matters, switch to SQL).\u003c/p\u003e\n\n\u003cp\u003eThe second is from a full disk. The easy to write a file in Go is to call os.WriteFile, which the first implementation did. But that means:\u003c/p\u003e\n\n\u003col\u003e\n\u003cli\u003eTruncating the database file\u003c/li\u003e\n\u003cli\u003eMaking multiple system calls to \u003ccode\u003ewrite(2)\u003c/code\u003e.\u003c/li\u003e\n\u003cli\u003eCalling \u003ccode\u003eclose(2)\u003c/code\u003e.\u003c/li\u003e\n\u003c/ol\u003e\n\n\u003cp\u003eA failure can occur in any of those system calls, resulting in a corrupt DB.\nSo this implementation creates a new file, loads the DB into it, and when that has all succeeded, uses \u003ccode\u003erename(2)\u003c/code\u003e.\nIt is not a panacea, our operating systems do not make all the promises we wish they would about rename.\nBut it is much better than the default.\u003c/p\u003e\n\n\u003ch2\u003eMemory aliasing\u003c/h2\u003e\n\n\u003cp\u003eA nasty issue I have run into twice is aliasing memory. This involves doing something like:\u003c/p\u003e\n\n\u003cpre\u003e\u003ccode class=\"language-go\"\u003elist := []int{1, 2, 3}\ndb.Write(func() { db.List = list })\nlist[0] = 10 // editing the database!\n\u003c/code\u003e\u003c/pre\u003e\n\n\u003ch2\u003eSome changes you may want to consider\u003c/h2\u003e\n\n\u003cp\u003e\u003cstrong\u003eBackups.\u003c/strong\u003e An intermediate version of this code kept the previous database file on write.\nBut thereâ€™s an easier and even more robust strategy: never rename the file back to the original.\nAlways create a new file, \u003ccode\u003emydb.json.\u0026lt;timestamp\u0026gt;\u003c/code\u003e.\nOn starting, load the most recent file.\nThen when your data is worth backing up (if ever), have a separate program prune down the number of files and send them somewhere robust.\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eConstant memory.\u003c/strong\u003e Not in this implementation but you may want to consider, is removing the risk of a Read function editing memory.  You can do that with View* types generated by the \u003ca href=\"https://github.com/tailscale/tailscale/blob/main/cmd/viewer/viewer.go\"\u003eviewer\u003c/a\u003e tool. Itâ€™s neat, but more than quadruples the complexity of JSONFileDB, complicates the build system, and initially isnâ€™t very important in the sorts of programs I write. I have found several memory aliasing bugs in all the code Iâ€™ve written on top of a JSON file, but have yet to accidentally write when reading. Still, for large code bases Views are quite pleasant and well-worth considering about the point when a project should move to a real SQL.\u003c/p\u003e\n\n\u003cp\u003eThere is some room for performance improvements too (using cloner instead of unmarshalling a fresh copy of the data for writing), though I must point out again that needing more performance is a good sign it is time to move on to SQLite, or something bigger.\u003c/p\u003e\n\n\u003cp\u003eItâ€™s a tiny library.\nCopy and edit as needed.\nIt is an all-new implementation so I will be fixing bugs as I find them.\u003c/p\u003e\n\n\u003cp\u003e(As a bonus: this was my first time using a Go generic! ðŸ‘´ It went fine. Parametric polymorphism is ok.)\u003c/p\u003e\n\n\u003ch1\u003eA final thought\u003c/h1\u003e\n\n\u003cp\u003eWhy go out of my way to devise an inadequate replacement for a database?\u003c/p\u003e\n\n\u003cp\u003eMost projects fail before they start.\nThey fail because the\n\u003ca href=\"https://en.wikipedia.org/wiki/Activation_energy\"\u003eactivation energy\u003c/a\u003e\nis too high.\nOur dreams are big and usually too much, as dreams should be.\u003c/p\u003e\n\n\u003cp\u003eBut software is not building a house or traveling the world.\nYou can realize a dream with the tools you have on you now, in a few spare hours.\nThis is the great joy of it, you are free from physical and economic constraint.\u003c/p\u003e\n\n\u003cp\u003eIf you start. Be willing to compromise almost everything to start.\u003c/p\u003e\n\n\t",
  "link": "https://crawshaw.io/blog/jsonfile",
  "links": [
   "https://crawshaw.io/blog/jsonfile"
  ],
  "updated": "2024-02-06T00:00:00Z",
  "updatedParsed": "2024-02-06T00:00:00Z",
  "published": "2024-02-06T00:00:00Z",
  "publishedParsed": "2024-02-06T00:00:00Z",
  "author": {
   "name": "David Crawshaw",
   "email": "david@zentus.com"
  },
  "authors": [
   {
    "name": "David Crawshaw",
    "email": "david@zentus.com"
   }
  ],
  "guid": "https://crawshaw.io/blog/jsonfile"
 }
]